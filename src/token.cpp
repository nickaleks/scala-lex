#include "token.h"

const std::unordered_map<lexer::TokenType, std::string> lexer::Token::to_string = {
        {lexer::TokenType::Whitespace, "token<whitespace"},
        {lexer::TokenType::Abstract, "token<abstract>"},
        {lexer::TokenType::Case, "token<case>"},
        {lexer::TokenType::Catch, "token<catch>"},
        {lexer::TokenType::Class, "token<class>"},
        {lexer::TokenType::Def, "token<def>"},
        {lexer::TokenType::Do, "token<do>"},
        {lexer::TokenType::Else, "token<else>"},
        {lexer::TokenType::Extends, "token<extends>"},
        {lexer::TokenType::False, "token<false>"},
        {lexer::TokenType::Final, "token<final>"},
        {lexer::TokenType::Finally, "token<finally>"},
        {lexer::TokenType::For, "token<for>"},
        {lexer::TokenType::ForSome, "token<forSome>"},
        {lexer::TokenType::If, "token<if>"},
        {lexer::TokenType::Implicit, "token<implicit>"},
        {lexer::TokenType::Import, "token<import>"},
        {lexer::TokenType::Lazy, "token<lazy>"},
        {lexer::TokenType::Macro, "token<macro>"},
        {lexer::TokenType::Match, "token<match>"},
        {lexer::TokenType::New, "token<new>"},
        {lexer::TokenType::Null, "token<null>"},
        {lexer::TokenType::Object, "token<object>"},
        {lexer::TokenType::Override, "token<override>"},
        {lexer::TokenType::Package, "token<package>"},
        {lexer::TokenType::Private, "token<private>"},
        {lexer::TokenType::Protected, "token<protected>"},
        {lexer::TokenType::Return, "token<return>"},
        {lexer::TokenType::Sealed, "token<sealed>"},
        {lexer::TokenType::Super, "token<super>"},
        {lexer::TokenType::This, "token<this>"},
        {lexer::TokenType::Throw, "token<throw>"},
        {lexer::TokenType::Trait, "token<trait>"},
        {lexer::TokenType::Try, "token<try>"},
        {lexer::TokenType::True, "token<true>"},
        {lexer::TokenType::Type, "token<type>"},
        {lexer::TokenType::Val, "token<val>"},
        {lexer::TokenType::Var, "token<var>"},
        {lexer::TokenType::While, "token<while>"},
        {lexer::TokenType::With, "token<with>"},
        {lexer::TokenType::Yield, "token<yield>"},
        {lexer::TokenType::Underscore, "token<underscore>"},
        {lexer::TokenType::Colon, "token<colon>"},
        {lexer::TokenType::Equal, "token<equal>"},
        {lexer::TokenType::Lambda, "token<lambda>"},
        {lexer::TokenType::ForLoopIterator, "token<forLoopIterator>"},
        {lexer::TokenType::UpperBounds, "token<upperBounds>"},
        {lexer::TokenType::ViewBounds, "token<viewBounds>"},
        {lexer::TokenType::LowerBounds, "token<lowerBounds>"},
        {lexer::TokenType::TypeNotation, "token<typeNotation>"},
        {lexer::TokenType::PatternMatching, "token<patternMatching>"},
        {lexer::TokenType::EndOfExpression, "token<endOfExpression>"},
        {lexer::TokenType::InvalidToken, "token<invalidToken>"},
        {lexer::TokenType::OpenParenthesis, "token<openParenthesis>"},
        {lexer::TokenType::CloseParenthesis, "token<closeParenthesis>"},
        {lexer::TokenType::OpenBrace, "token<openBrace>"},
        {lexer::TokenType::CloseBrace, "token<closeBrace>"},
        {lexer::TokenType::OpenBracket, "token<openBracket>"},
        {lexer::TokenType::CloseBracket, "token<closeBracket>"},
        {lexer::TokenType::NewLine, "token<newLine>"},
        {lexer::TokenType::Tab, "token<tab>"}
};